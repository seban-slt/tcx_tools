# Turbo Copy 3/Turbo Copy 4 data stream analyzer & decompressor
#
# done by Seban/Slight
#
# This is very simple & lame python code (I never programmed in Python
# so this is an experiment, maybe I learn something new? ;)
#
# This simple script was used to extract files from old tape images
#
# The data structure is "guessed" from loader code,
# I'm not sure this will be correct for all cases
# I have only a few example files, and because those files
# was generated by Turbo Copy 3 or 4, the file extension TCX was selected
# for those files.
#
# >>> Python 3.8.2 was used to test & run this code <<<
#
# .O.	released at 2020.05.09
# ..O
# OOO	>>> Public Domain <<<

import os
import sys

# example cmd-line parameters, needed only when testing inside the IDLE Python IDE
#sys.argv = [sys.argv[0], 'test_files/tcx/super_cobra.tcx']
#sys.argv = [sys.argv[0], 'test_files/tcx/ixion2.tcx','0x61']
#sys.argv = [sys.argv[0], 'test_files/tcx/spy_vs_spy.tcx','0xaf']
sys.argv = [sys.argv[0], 'test_files/tcx/universal_hero.tcx','0xb4']

# if want do see stream debug info set to "True"
stream_debug_mode = False

if (len(sys.argv) < 2):
    print("No input file specified! Exiting.");
    exit(-1)

input_file_name = sys.argv[1]
input_file_size = os.path.getsize(input_file_name)

print("\nInput file is",input_file_name,"and the file size is", input_file_size, "bytes.")

in_data = bytearray( open(input_file_name,"rb").read() )

print("TCX data loaded, checking data...\n")

# check if xor key is passed via command line
if (len(sys.argv) == 3):
    xor_key = int(sys.argv[2],16)

    # XOR input data with passed XOR key   
    for x in range(0,len(in_data)):
        in_data[x] ^= xor_key
else:
    xor_key = 0

print("Header is: $%02x%02x" %(in_data[0],in_data[1]))
# check if the input file have correct Atari-DOS file header ($ff,$ff)
if ((in_data[0] != 0xff) or (in_data[1] != 0xff)):
    print("\nNot a Atari DOS file header! Wrong file type? Data encrypted?")
    print("Maybe the XOR key for data decoding is wrong or not given?")

    if (in_data[0] == in_data[1]):
        print("\n>>> But if I can guess try this XOR key value: 0x%02X <<<\n" %(in_data[0] ^ int(0xff)))

    exit(-1)

# at the begining put Atari-DOS header on the output data array
out_data = bytearray(b'\xFF\xFF')

# zeroize block counter
blk = 0;

# skip atari header file ($ff,$ff)
i = 2

# zeroinze garbage data counter
garbage_data_size = 0

# main data processing loop
while (i < len(in_data)):

    # check if any sensible amount of data is present
    if (len(in_data) - i) < 4:
        break

    # get the block addresses & calculate block size
    blk_start = in_data[i+0]+256*in_data[i+1]
    blk_end   = in_data[i+2]+256*in_data[i+3]
    blk_len   = (blk_end - blk_start) + 1

    # check block validity
    if (blk_len > 0) and (blk_start != (xor_key+256*xor_key)):

        if stream_debug_mode:
            print()

        print("block %03d: $%04x-$%04x" %(blk,blk_start,blk_end))

        # copy header block data to output
        out_data.append(in_data[i+0]);
        out_data.append(in_data[i+1]);
        out_data.append(in_data[i+2]);
        out_data.append(in_data[i+3]);

        # move input data pointer to next valid data
        i += 4

        # increment block counter
        blk += 1;
        
    else:
        # if no valid data block, skip processing

        garbage_data_size += 1

        # slide to next input byte
        i+=1
        continue

    # block processing loop
    while (blk_len):

        # check for RLE zero escape code
        if (in_data[i] == 0xbf):

            # get number of zeros from stream
            cnt = in_data[i+1]

            # send the zeros to output
            for r in range(0,cnt):
                out_data.append(0x00)
        
            # move input data pointer to next valid data
            i += 2
            # decremant block length
            blk_len -= cnt;

            # print info message
            if stream_debug_mode:
                print("\t@ $%04x RLE zero block, len =%5i" %(i,r))

        # check for RLE byte escape code
        elif (in_data[i] == 0xcf):

            # get number of repetition from input stream
            cnt = in_data[i+1]

            # get the value of repeated byte
            val = in_data[i+2]

            # send the repeated byte to output
            for r in range(0,cnt):
                out_data.append(val)

            # move input data pointer to next valid data
            i += 3

            # decrement block length
            blk_len -= cnt;

            # print info message
            if stream_debug_mode:
                print("\t@ $%04x RLE fill block, len =%5i" %(i , cnt), "(",format(val,"02x"),")")

        # if plan byte on input stream then copy to output
        else:
            out_data.append(in_data[i])

            # move input data pointer to next byte
            i +=1

            # decrement block length
            blk_len -=1

if (garbage_data_size):
    print("\n!!! WARNING !!! Bad header data was detected, skipped", garbage_data_size, "garbage byte(s).")

# processing done message        
print("\nInput data processing done,", blk, "block(s) processed, generating output file...");

# generate output filename
output_filename = input_file_name + ".xex"

# calculate the size diff
size_diff = len(out_data) - input_file_size

# print info messagaes about output file/data
print("Output file is", output_filename, "and the file size is", len(out_data), "bytes.")

# write out decompressed data
open(output_filename,"wb").write(out_data)

# print out last message and exit!
print("Processing done, output file written, IN/OUT file size diff is", size_diff, "byte(s).")
